<!DOCTYPE html>
<html lang="en">
    <head>
        <link rel="stylesheet" type="text/css" href="styles.css">
        <meta charset="UTF-8">
        <title>tree</title>
    </head>
    <body class="body">
        <div class="mainDiv">
            <div class="row separate-small-top">
                <h1>Краткое введение в тему фракталов и их построение</h2>
            </div>

            <div class="canvas-wrapper">
                <hr class="green-separator" />
            </div>
            <div class="canvas-wrapper">
                <div class="row separate-small-top">
                    <h2>Фрактальное дерево</h2>
                </div>
                <div class="block">
                    <div class="fractal-block">
                        <div class="row">
                            <canvas id="fractal-tree" width="800" height="650"></canvas>
                        </div>
                        <div class="row">
                            <output id="fractal-tree-slider-val" class="tree-size-label">160</output>
                        </div>
                        <div class="row separate-small-top">                    
                            <input id="fractal-tree-slider" 
                                style="direction: rtl;"
                                type="range"
                                min="10"
                                max="160"
                                value="160"
                                step="30"
                            />
                        </div>
                        <div class="row ">
                            <label for="fractal-tree-slider">Ширина ветки</label>
                        </div>
                    </div>
                    <div class="info-block">
                        <p>
                            <b>Шаги построения фрактального дерева.</b><br/>
                            &nbsp;<br/>
                            Первый шаг - отрезок. Этот отрезок - это ствол дерева. <br/>
                            От конца ствола отводятся два новых отрезка под углом. Эти отрезки будут первыми ветвями. <br/>
                            Далее к каждому концу ветвей снова добавляются по две ветви под углом. С каждым новым этапом ветви делаются короче.<br/>
                            &nbsp;<br/>
                            Продолжая в том же духе, с каждым новым уровнем ветвления дерево становится все более сложным и похожим на настоящее дерево.
                        </p>
                    </div>
                </div>
            </div>

            <div class="canvas-wrapper">
                <hr class="green-separator" />
            </div>

            <div class="canvas-wrapper">
                <div class="row separate-small-top">
                    <h2>Снежинка Коха</h2>
                </div>
                <div class="block">
                    <div class="fractal-block">
                        <div class="row">
                            <canvas id="fractal-koch-snowflake" width="800" height="650"></canvas>
                        </div>
                        <div class="row">
                            <output id="snowflake-slider-val" class="snowflake-label">2</output>
                        </div>
                        <div class="row separate-small-top">
                            <input id="snowflake-slider" type="range" min="-1" max="5" value="1" />
                        </div>
                        <div class="row">
                            <label for="snowflake-slider">Лимит</label>
                        </div>
                    </div>
                    <div class="info-block">
                        <p>
                        <b>Шаги построения кривой Коха.</b><br/>
                        &nbsp;<br/>
                        Первый шаг — равносторонний треугольник.<br/>
                        Потом каждая сторона делится на три равные части, центральная из которых достраивается до равностороннего треугольника и затем основание убирается.<br/>
                        Далее к каждой стороне применяется такая же операция.<br/>
                        Продолжая в том же духе, можно получать всё новые и новые линии (все они будут ломаными).
                        </p>
                        <p>&nbsp;</p>
                        <p>
                        Кривая Коха также может начинать своё построение не из равностороннего треугольника, а просто из отрезка и тогда перед всей операцией добавляется еще один дополнительный шаг - создание треугольника.
                        </p>
                    </div>
                </div>
            </div>

            <div class="canvas-wrapper">
                <hr class="green-separator" />
            </div>

            <div class="canvas-wrapper">
                <div class="row separate-small-top">
                    <h2>Папоротник Барнсли</h2>
                </div>
                <div class="block">
                    <div class="fractal-block2">
                        <img src="barnsley-fern-calc.png" />
                    </div>
                    <div class="info-block">
                        <p>
                            Папоротник Бансли является одним из основных примеров "самоподобных" множеств, т.е. представляет собой математически генерируемый "шаблон", воспроизводимый при любом увеличении или уменьшении количества операций<br/>
                            &nbsp;<br/>
                            Папоротник Барнсли теоретически может быть построен вручную. Т.е. Вы берете ручку, лист в бумаги в мелкую клетку и следуете матрице коэффициентов. Однако, количество необходимый итераций исчисляется десятками тысяч, что делает использование компьютера, мягко говоря, желательным.<br/>
                            &nbsp;<br/>
                            &nbsp;<br/>
                            <i class="smaller-info-font">
                                Первая точка находится в начале координат (х0 = 0, у0 = 0)<br/>
                                затем новые точки вычисляются путем многократного случайного применения одного из следующих четырех преобразований координат:<br/>
                                &nbsp;<br/>
                                (1) x<sub>n+1</sub> = 0; y<sub>n+1</sub> = 0.16&middot;y<sub>n</sub>.<br/>
                                <i class="smaller-info-font">Данное преобразование выбирается в 1% случаев и указывает на точку у основания "стебля". Эта часть рисунка в результате многократных преобразований завершается первой.</i><br/>
                                &nbsp;<br/>
                                (2) x<sub>n+1</sub> = 0.85&middot;x<sub>n</sub> + 0.04&middot;y<sub>n</sub>; y<sub>n+1</sub> = −0.04&middot;x<sub>n</sub> + 0.85&middot;y<sub>n</sub> + 1.6.<br/>
                                <i class="smaller-info-font">Преобразование (2) используется в 85% случаев и указывает на любую точку листовки попадающую в красный треугольник</i><br/>
                                &nbsp;<br/>
                                (3) x<sub>n+1</sub> = 0.2&middot;x<sub>n</sub> − 0.26&middot;y<sub>n</sub> ; y<sub>n+1</sub> = 0.23&middot;x<sub>n</sub> + 0.22&middot;y<sub>n</sub>  + 1.6.<br/>
                                <i class="smaller-info-font">Выбирается в 7% случаев - попадания точки в синий треугольник и симметричного ему относительно главного стебля треугольника.</i><br/>
                                &nbsp;<br/>
                                (4)x<sub>n+1</sub> = −0.15&middot;x<sub>n</sub> + 0.28&middot;y<sub>n</sub>; y<sub>n+1</sub> = 0.26&middot;x<sub>n</sub> + 0.24&middot;y<sub>n</sub> + 0.44.<br/>
                                <i class="smaller-info-font">В оставшихся 7% случаев используется преобразование (4) - для симметричных преобразованию (3) относительно стеблей 2-го порядка позиций.</i><br/>
                            </i>
                        </p>
                    </div>
                </div>
                <div class="fractal-block">
                    <div class="row">
                        <canvas id="fractal-barnsley-fern" width="600" height="800"></canvas>
                    </div>
                    <div class="row">
                        <output id="fractal-barnsley-fern-val" class="snowflake-label">5000</output>
                    </div>
                    <div class="row separate-small-top">
                        <input id="fractal-barnsley-fern-slider" type="range" min="2000" max="50000" value="5000" />
                    </div>
                    <div class="row">
                        <label for="fractal-barnsley-fern-slider">Повторения</label>
                    </div>
                    <div class="row separate-small-top separate-small-bottom">
                        <div>&nbsp;</div>
                    </div>
                </div>
            </div>

            <div class="canvas-wrapper">
                <hr class="green-separator" />
            </div>

            <div class="canvas-wrapper">
                <div class="row separate-small-top">
                    <h2>Дерево Пифагора</h2>
                </div>
                <div class="block">
                    <div class="fractal-block">

                        <div class="row">
                            <canvas id="fractal-pythagoras-tree" width="640" height="640"></canvas>
                        </div>
                        <div class="row">
                            <output id="fractal-pythagoras-tree-val" class="snowflake-label">1</output>
                        </div>
                        <div class="row separate-small-top">
                            <input id="fractal-pythagoras-tree-slider" type="range" min="1" max="14" value="1" />
                        </div>
                    </div>
                    <div class="info-block">
                        <p>
                            <b>Шаги построения дерева Пифагора.</b><br/>
                            &nbsp;<br/>
                            Первый шаг - квадрат.<br/>
                            Этот квадрат - это основание всего дерева. На одной из сторон квадрата рисуется прямоугольный треугольник так, чтобы гипотенуза была равна стороне квадрата.<br/>
                            На каждом катете треугольника рисуются новые квадраты. Эти квадраты будут основаниями для следующих ветвей дерева. <br/>
                            &nbsp;<br/>
                            Продолжая в том же духе каждый последующий шаг создает новые "ветви" дерева, и если продолжать его бесконечно, получится фрактал с бесконечным количеством ветвей.<br/>
                        </p>
                    </div>
                </div>
            </div>

            <div class="canvas-wrapper">
                <hr class="green-separator" />
            </div>
            <div class="signature-bottom">
                <p>Прищенко София, 2024</p>
            </div>
        </div>
        
        <script type="text/javascript">
            //
            // Common method:
            //
            function cleanCanvas(canvasObj) {

                var canvasContext = canvasObj.getContext("2d");

                canvasContext.setTransform(1, 0, 0, 1, 0, 0);
                canvasContext.clearRect(-canvasObj.width, -canvasObj.height, canvasObj.width, canvasObj.height);
                canvasContext.clearRect(0, 0, canvasObj.width, canvasObj.height);

                return canvasContext;
            }
            //
            // Fractal Tree:
            // 1) function:
            function drawFranctalTree(canvasObj, minLen = 140) {
                
                let context = cleanCanvas(canvasObj);

                function draw(startX, startY, len, angle, branchWidth) {
                    
                    context.lineWidth = branchWidth;

                    context.beginPath();
                    context.save();

                    context.translate(startX, startY);
                    context.rotate(angle * Math.PI/180);
                    context.moveTo(0, 0);
                    context.lineTo(0, -len);
                    context.stroke();

                    context.shadowBlur = 15;
                    
                    //context.shadowColor = "rgba(0,0,0,0.8)";
                    context.shadowColor = "rgba(64,134,80,0.8)";

                    if (len < minLen) {
                        context.restore();
                        return;
                    }
                    draw(0, -len, len*0.8, angle-15, branchWidth*0.8);
                    draw(0, -len, len*0.8, angle+15, branchWidth*0.8);

                    context.restore();
                }

                let width = canvasObj.width;
                let height = canvasObj.height;
                context.setTransform(1, 0, 0, 1, 0, 0);
                context.strokeStyle = "rgba(45,112,61,0.8)";
                draw(400, 700, 140, 0, 10);
            }
            //
            // 2) place on page:
            var treeCanvasObj = document.getElementById("fractal-tree");
            var treeLengthSlider = document.getElementById("fractal-tree-slider");
            drawFranctalTree(treeCanvasObj, treeLengthSlider.value);
            
            // 3) react on slider update:
            treeLengthSlider.addEventListener('input', (event) => {
                drawFranctalTree(treeCanvasObj, treeLengthSlider.value);
                document.getElementById("fractal-tree-slider-val").value = treeLengthSlider.value;
            });

            //
            // Koch curve/snowflake:
            // 1) function:
            function drawKochSnowflake(canvasObj, silderId) {
                let context = cleanCanvas(canvasObj);
                let width = canvasObj.width;
                let height = canvasObj.height;

                const slider = document.getElementById(silderId);
                slider.oninput = (ev, ui) => {
                    context.clearRect(-width/2, -height/2, width, height);
                    drawSnflake();
                };

                context.strokeStyle = "rgba(125,66,148,0.8)";
                context.lineWidth = 3;

                const drawSnflake = () => {
                    context.setTransform(1, 0, 0, 1, 0, 0);
                    context.translate(width/2, height/2);

                    const p0 = {
                        x: 0,
                        y: -321
                    },
                    p1 = {
                        x: 278,
                        y: 160
                    },
                    p2 = {
                        x: -278,
                        y: 160
                    };

                    const koch = (p0, p1, limit) => {
                        let dx = p1.x - p0.x,
                            dy = p1.y - p0.y,
                            dist = Math.sqrt(dx*dx + dy*dy),
                            unit = dist/3,
                            angle = Math.atan2(dy, dx),
                            pA = {
                                x: p0.x + dx/3,
                                y: p0.y + dy/3
                            },
                            pC = {
                                x: p1.x - dx/3,
                                y: p1.y - dy/3
                            },
                            pB = {
                                x: pA.x + Math.cos(angle - Math.PI/3) * unit,
                                y: pA.y + Math.sin(angle - Math.PI/3) * unit
                            };
                        
                            if (limit > 0) {
                                koch(p0, pA, limit - 1);
                                koch(pA, pB, limit - 1);
                                koch(pB, pC, limit - 1);
                                koch(pC, p1, limit - 1);
                            } else if (limit < 0) {
                                context.beginPath();
                                context.moveTo(p0.x, p0.y);
                                context.lineTo(p1.x, p1.y);
                                context.stroke();
                            } else {
                                context.beginPath();
                                context.moveTo(p0.x, p0.y);
                                context.lineTo(pA.x, pA.y);
                                context.lineTo(pB.x, pB.y);
                                context.lineTo(pC.x, pC.y);
                                context.lineTo(p1.x, p1.y);
                                context.stroke();
                            }
                    };

                    koch(p0, p1, slider.value);
                    koch(p1, p2, slider.value);
                    koch(p2, p0, slider.value);
                };

                drawSnflake();
            };
            //
            // 2) place on page:
            var snowflakeCanvas = document.getElementById("fractal-koch-snowflake");
            drawKochSnowflake(snowflakeCanvas, "snowflake-slider");
            // 3) update slider value:
            document.getElementById("snowflake-slider").addEventListener("input", (event) => {
                document.getElementById("snowflake-slider-val").value = +document.getElementById("snowflake-slider").value + 1;
            });


            //
            // Barnsley fern
            // 1) function:
            function drawBarnsleyFern(canvasObj, iterationCount) {
                let context = cleanCanvas(canvasObj);

                let width = canvasObj.width, height = canvasObj.height;
                let x = 0.,
                    y = 0.,
                    xw = 0.,
                    yw = 0.,
                    r;

                const randgp = (max) => Math.floor(Math.random() * max);

                for (let i = 0; i < iterationCount; i++) {
                    r = randgp(100);
                    if (r <= 1) {
                        xw = 0;
                        yw = 0.16*y;
                    } else if (r <= 8) {
                        xw = 0.2 * x - 0.26 * y;
                        yw = 0.23 * x + 0.22 * y + 1.6;
                    } else if (r <= 15) {
                        xw = -0.15 * x + 0.28 * y;
                        yw = 0.26 * x + 0.24 * y + 0.44;
                    } else {
                        xw = 0.85 * x + 0.04 * y;
                        yw = -0.04 * x + 0.85 * y + 1.6;
                    }
                    x = xw;
                    y = yw;
                    context.fillStyle = "green";
                    context.fillRect(x * 50 + 260, -y * 50 + 540, 1, 1);
                }
            }

            // 2) place on the page:
            var barnsleyFernCanvas = document.getElementById("fractal-barnsley-fern");
            var barnsleyFernSlider = document.getElementById("fractal-barnsley-fern-slider");
            drawBarnsleyFern(barnsleyFernCanvas, barnsleyFernSlider.value);

            // 3) update slider value:
            barnsleyFernSlider.oninput = (ev, ui) => {
                document.getElementById("fractal-barnsley-fern-val").value = barnsleyFernSlider.value;
                drawBarnsleyFern(barnsleyFernCanvas, barnsleyFernSlider.value);
            };

            // Pythagoras tree:
            // 1) function:
            /* copied from stackoverflow */
            function HSVtoRGB(h, s, v) {
                var r, g, b, i, f, p, q, t;

                i = Math.floor(h * 6);
                f = h * 6 - i;
                p = v * (1 - s);
                q = v * (1 - f * s);
                t = v * (1 - (1 - f) * s);
                switch (i % 6) {
                    case 0: r = v, g = t, b = p; break;
                    case 1: r = q, g = v, b = p; break;
                    case 2: r = p, g = v, b = t; break;
                    case 3: r = p, g = q, b = v; break;
                    case 4: r = t, g = p, b = v; break;
                    case 5: r = v, g = p, b = q; break;
                }
                return "rgb("
                    + Math.round(r * 255) + ","
                    + Math.round(g * 255) + ","
                    + Math.round(b * 255) + ")";
            }

            function drawPythagorasTree(context, x1, y1, x2, y2, depthLimit, depth) {
                // var depthLimit = 12;
                var hue = 0.15;

                if (depth == depthLimit)
                    return;

                var dx = x2 - x1;
                var dy = y1 - y2;

                var x3 = x2 - dy;
                var y3 = y2 - dx;
                var x4 = x1 - dy;
                var y4 = y1 - dx;
                var x5 = x4 + 0.5 * (dx - dy);
                var y5 = y4 - 0.5 * (dx + dy);

                context.beginPath();
                context.moveTo(x1, y1);
                context.lineTo(x2, y2);
                context.lineTo(x3, y3);
                context.lineTo(x4, y4);
                context.closePath();

                context.fillStyle = HSVtoRGB(hue + depth * 0.02, 1, 1);
                context.fill();
                context.strokeStyle = "lightGray";
                context.stroke();

                context.beginPath();
                context.moveTo(x3, y3);
                context.lineTo(x4, y4);
                context.lineTo(x5, y5);
                context.closePath();

                var hsv = (depth == 0) ? (hue + 0.4 * 0.035) : (hue + depth * 0.035);
                context.fillStyle = HSVtoRGB(hsv, 1, 1);
                context.fill();
                context.strokeStyle = "lightGray";
                context.stroke();

                drawPythagorasTree(context, x4, y4, x5, y5, depthLimit, depth + 1);
                drawPythagorasTree(context, x5, y5, x3, y3, depthLimit, depth + 1);
            }

            // 2) place on the page:
            var canvasPyTree = cleanCanvas(document.getElementById("fractal-pythagoras-tree"));
            var pyTreeSlider = document.getElementById("fractal-pythagoras-tree-slider");
            drawPythagorasTree(canvasPyTree, 275, 500, 375, 500, 1, 0);

            // 3) update slider value:
            pyTreeSlider.oninput = (ev, ui) => {
                document.getElementById("fractal-pythagoras-tree-val").value = pyTreeSlider.value;
                let canvas = cleanCanvas(document.getElementById("fractal-pythagoras-tree"));
                drawPythagorasTree(canvas, 275, 500, 375, 500, pyTreeSlider.value, 0);
            };
        </script>
    </body>
</html>